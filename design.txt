DESIGN PROBLEMS TO SOLVE:
- the storage of the values in the dictionary structure (currently strings regardless). Is the current way efficient?
    - Ideally the values should be stored in the radtypes classes so that the values are comparable with the actual values in the AVPs. However given the values will be supplied from GUI/CLI, they will all initially be strings and then be converted. The validation process may be ambiguious in this case though.
    DONE: values in dictionary storage are now stored in radtypes objects.

- storage of values in the AVP data structures (currently it's the radtypes classes).
    - should the value be in string format and then converted by before producing a dump?
    - should I keep it as it is right now?

- the value storage currently is a list of tuples. [ (name, value), (name1, value1) ].
    - Given the size of the list isn't big, the linear search may be acceptable here. Should I consider changing it to dictionary?
    (Currently converting to dict every time we need to check)


DESIGN OF THE DICTIONARY STRUCTURE:

Dictionary = {
    ATTRIBUTE_NAME : AttributeDef Obj,
    ...
}

class AttributeDef {
    attr_name           # name of the attribute (key)
    attr_id             # numberic ID of the attribute
    attr_type           # string representation of type
    attr_vendor         # VendorDef object reference (1->1)
    attr_defined_values # list of tuples (name_str, value_str)
}

class VendorDef {
    vendor_name         # name of the vendor
    vendor_id           # numeric ID
}

class Dictionary {
    attributes          # dict { attr_name : AttributeDef obj, ... }
    vendors             # dict { vendor_name : VendorDef obj, ... }
    values              # dict { attr_name : (name, value) }

    # values dictionary is used to add the values to attributes
    # after all files are processed since the values for
    # an attribute can be spread across multiple files.

    methods {
        get_attribute       # get the attribute by name

        read_dictionaries   # read all dictionary files following
                            # the $INCLUDE clause

        read_dictionary     # start reading dictionaries and process
                            # values once all files are processed

        read_one_file       # parse a single file and fill the data
                            # structure. Returns a list of included
                            # files
    }
}

DESIGN OF THE AVP OBJECT:
class RadiusAvp {
    avp_def             # AttributeDef (definition of the attribute)
    avp_code            # number value of the attribute (IntegerType obj)
    avp_value           # value of the avp (radtypes[avp_def.avp_type] obj
    avp_subavp          # list of sub AVPs (in case of the vendor specific).

    methods {
        dump            # dump binary representation of the AVP
    }
}

DESIGN OF RADTYPES OBJECT:


DESIGN OF LIBRADI LIBRARY:
    libradi.radtypes.*      # type objects for storing values as per
                            # dictionary attribute type

    libradi.dictionary.*    # functions related to dictionary

    libradi.*               # radius related objects/functions
